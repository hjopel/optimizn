{"version":3,"sources":["components/Animation/Shaders/shader.js","components/Animation/index.js","App.js","reportWebVitals.js","index.js"],"names":["Shader","uniforms","uTime","value","uPointsize","uDecay","uWave","uColor","THREE","uColorVarying","vertexShader","fragmentShader","Index","props","ref","useRef","camRef","useFrame","clock","elapsed","getElapsedTime","getDelta","current","material","OrbitControls","PerspectiveCamera","makeDefault","fov","position","rotation","Math","PI","intensity","castShadow","angle","penumbra","shadow-mapSize-width","shadow-mapSize-height","receiveShadow","scale","attach","args","Text","color","fontSize","App","style","width","height","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"qOACMA,EAAS,CACXC,SAAU,CACRC,MAAO,CAAEC,MAAO,GAChBC,WAAY,CAAED,MAAO,GACrBE,OAAQ,CAAEF,MAAO,IACjBG,MAAO,CAAEH,MAAO,IAChBI,OAAQ,CAAEJ,MAAO,I,KAAIK,OAAY,YACjCC,cAAe,CAAEN,MAAO,KAE1BO,aAAa,60NAiNbC,eAAe,2U,wBCnNJ,SAASC,EAAMC,GAC1B,IAAMC,EAAMC,mBACNC,EAASD,mBASf,OARAE,aAAS,YAAY,IAAVC,EAAS,EAATA,MACDC,EAAUD,EAAME,iBACRF,EAAMG,WACpBP,EAAIQ,QAAQC,SAAStB,SAASC,MAAMC,MAAkB,GAAVgB,KAM5C,qCACA,cAACK,EAAA,EAAD,IACA,cAACC,EAAA,EAAD,CAAmBC,aAAW,EAACZ,IAAKE,EAAQW,IAAK,GAC7CC,SAAU,CAAC,EAAG,EAAG,GAAIC,SAAU,CAAC,EAAGC,KAAKC,GAAG,KAC/C,4BAAYH,SAAU,EAAE,IAAK,IAAK,IAAKI,UAAW,IAClD,8BAAcA,UAAW,KACzB,2BACEC,YAAU,EACVC,MAAO,GACPC,SAAU,EACVP,SAAU,CAAC,EAAG,GAAI,IAClBI,UAAW,EACXI,uBAAsB,KACtBC,wBAAuB,OAEzB,uBAAMvB,IAAKA,EAAKmB,YAAU,EAACK,eAAa,EAACC,MAAO,GAAKX,SAAU,CAAC,EAAI,EAAI,GAAxE,UACI,2CAA2BY,OAAO,WAAWC,KAAM,CAAC,EAAE,MACtD,gCAAgBA,KAAM,CAACzC,QAE3B,kCACI,cAAC0C,EAAA,EAAD,CACId,SAAU,EAAE,EAAI,EAAI,GACpBe,MAAO,UACPC,SAAU,GAHd,SAKK,cAEL,cAACF,EAAA,EAAD,CACId,SAAU,EAAE,KAAM,EAAK,GACvBe,MAAO,UACPC,SAAU,GAHd,SAKK,+CClCFC,MAdf,WAEE,OACE,qBAAMC,MAAO,CAAEC,MAAO,QAASC,OAAQ,SAAvC,SAEE,cAAC,IAAD,UACE,cAAC,EAAD,SCEOC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.a65fb0a1.chunk.js","sourcesContent":["import * as THREE from 'three'\r\nconst Shader = {\r\n    uniforms: {\r\n      uTime: { value: 0.0},\r\n      uPointsize: { value: 1.0},\r\n      uDecay: { value: 0.4 },\r\n      uWave: { value: 10.0 },\r\n      uColor: { value: new THREE.Color('#C91E1E')},\r\n      uColorVarying: { value: 11.0 }\r\n    },\r\n    vertexShader: `\r\n    //\r\n    //many thanks to Victor Vergara for the inspiration & initial shader\r\n  // GLSL textureless classic 3D noise \"cnoise\",\r\n  // with an RSL-style periodic variant \"pnoise\".\r\n  // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\r\n  // Version: 2011-10-11\r\n  //\r\n  // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\r\n  // Distributed under the MIT license. See LICENSE file.\r\n  // https://github.com/ashima/webgl-noise\r\n  //\r\n\r\n  vec3 mod289(vec3 x)\r\n  {\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n  }\r\n\r\n  vec4 mod289(vec4 x)\r\n  {\r\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n  }\r\n\r\n  vec4 permute(vec4 x)\r\n  {\r\n    return mod289(((x*34.0)+1.0)*x);\r\n  }\r\n\r\n  vec4 taylorInvSqrt(vec4 r)\r\n  {\r\n    return 1.79284291400159 - 0.85373472095314 * r;\r\n  }\r\n\r\n  vec3 fade(vec3 t) {\r\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n  }\r\n\r\n  // Classic Perlin noise\r\n  float cnoise(vec3 P)\r\n  {\r\n    vec3 Pi0 = floor(P); // Integer part for indexing\r\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n    Pi0 = mod289(Pi0);\r\n    Pi1 = mod289(Pi1);\r\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n    vec4 iz0 = Pi0.zzzz;\r\n    vec4 iz1 = Pi1.zzzz;\r\n\r\n    vec4 ixy = permute(permute(ix) + iy);\r\n    vec4 ixy0 = permute(ixy + iz0);\r\n    vec4 ixy1 = permute(ixy + iz1);\r\n\r\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n    gx0 = fract(gx0);\r\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n    vec4 sz0 = step(gz0, vec4(0.0));\r\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n    gx1 = fract(gx1);\r\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n    vec4 sz1 = step(gz1, vec4(0.0));\r\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 *= norm0.x;\r\n    g010 *= norm0.y;\r\n    g100 *= norm0.z;\r\n    g110 *= norm0.w;\r\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 *= norm1.x;\r\n    g011 *= norm1.y;\r\n    g101 *= norm1.z;\r\n    g111 *= norm1.w;\r\n\r\n    float n000 = dot(g000, Pf0);\r\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n    float n111 = dot(g111, Pf1);\r\n\r\n    vec3 fade_xyz = fade(Pf0);\r\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 2.2 * n_xyz;\r\n  }\r\n\r\n  // Classic Perlin noise, periodic variant\r\n  float pnoise(vec3 P, vec3 rep)\r\n  {\r\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n    Pi0 = mod289(Pi0);\r\n    Pi1 = mod289(Pi1);\r\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n    vec4 iz0 = Pi0.zzzz;\r\n    vec4 iz1 = Pi1.zzzz;\r\n\r\n    vec4 ixy = permute(permute(ix) + iy);\r\n    vec4 ixy0 = permute(ixy + iz0);\r\n    vec4 ixy1 = permute(ixy + iz1);\r\n\r\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n    gx0 = fract(gx0);\r\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n    vec4 sz0 = step(gz0, vec4(0.0));\r\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n    gx1 = fract(gx1);\r\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n    vec4 sz1 = step(gz1, vec4(0.0));\r\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n    g000 *= norm0.x;\r\n    g010 *= norm0.y;\r\n    g100 *= norm0.z;\r\n    g110 *= norm0.w;\r\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n    g001 *= norm1.x;\r\n    g011 *= norm1.y;\r\n    g101 *= norm1.z;\r\n    g111 *= norm1.w;\r\n\r\n    float n000 = dot(g000, Pf0);\r\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n    float n111 = dot(g111, Pf1);\r\n\r\n    vec3 fade_xyz = fade(Pf0);\r\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n    return 1.5 * n_xyz;\r\n  }\r\n  \r\n  // Turbulence By Jaume Sanchez => https://codepen.io/spite/\r\n  \r\n  varying float qnoise;\r\n  varying float displacement;\r\n  \r\n  uniform float uTime;\r\n  uniform float uPointsize;\r\n  uniform float uDecay;\r\n  uniform float uWave;\r\n  uniform float uColorVarying;\r\n\r\n  float turbulence( vec3 p) {\r\n    float t = - 0.1;\r\n    for (float f = 1.0 ; f <= 3.0 ; f++ ){\r\n      float power = pow( 2.0, f );\r\n      t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\r\n    }\r\n    return t;\r\n  }\r\n\r\n  void main() {\r\n    float noise = (1.0 *  - uWave) * turbulence( uDecay * abs(normal + uTime));\r\n    qnoise = (2.0 *  - uColorVarying) * turbulence( uDecay * abs(normal + uTime));\r\n    float b = pnoise(position + vec3( uTime ), vec3( 1.0 ) );\r\n    displacement = - sin(noise) + cos(b * 0.5);\r\n\r\n    vec3 newPosition = position + (normal * displacement);\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\r\n    gl_PointSize = uPointsize;\r\n\r\n  }\r\n    `,\r\n    fragmentShader: `\r\n    varying float qnoise;\r\n    uniform vec3 uColor;\r\n    uniform float uTime;\r\n\r\n  void main() {\r\n    float r, g, b;\r\n\r\n    r = cos(qnoise + uColor.x + tan(uTime * 0.8));\r\n    g = cos(qnoise + uColor.y + cos(uTime));\r\n    b = cos(qnoise + uColor.z + sin(uTime * 8.0));\r\n    \r\n    gl_FragColor = vec4(r, g, b, 1.0);\r\n  }\r\n    `\r\n};\r\n\r\nexport { Shader };","\r\nimport { useRef } from 'react'\r\nimport Background from './Background'\r\nimport {Shader} from './Shaders/shader'\r\nimport {useFrame} from '@react-three/fiber'\r\nimport { Text, PerspectiveCamera, OrbitControls, useHelper} from '@react-three/drei';\r\n\r\nimport { CameraHelper, MathUtils, Camera } from 'three';\r\nexport default function Index(props){\r\n    const ref = useRef();\r\n    const camRef = useRef();\r\n    useFrame(({clock})=>{\r\n        const elapsed = clock.getElapsedTime();\r\n        const delta = clock.getDelta()\r\n        ref.current.material.uniforms.uTime.value = elapsed * 0.2;\r\n        // camRef.current.position.x = camRef.current.position.x * Math.cos(0.02) + camRef.current.position.z * Math.sin(0.02);\r\n        // camRef.current.position.z = camRef.current.position.z * Math.cos(0.02) - camRef.current.position.x * Math.sin(0.02);\r\n    })\r\n    // useHelper(camRef, CameraHelper, 1, 'hotpink')\r\n    return (\r\n        <>\r\n        <OrbitControls />\r\n        <PerspectiveCamera makeDefault ref={camRef} fov={75} \r\n            position={[0, 0, 5]} rotation={[0, Math.PI,0]}/>\r\n        <pointLight position={[-10, -10, -10]} intensity={1} />\r\n        <ambientLight intensity={0.4}/>\r\n        <spotLight\r\n          castShadow\r\n          angle={0.3}\r\n          penumbra={1}\r\n          position={[0, 10, 20]}\r\n          intensity={5}\r\n          shadow-mapSize-width={1024}\r\n          shadow-mapSize-height={1024}\r\n        />\r\n        <mesh ref={ref} castShadow receiveShadow scale={0.5} position={[2.0,0.0,0.0]}>\r\n            <icosahedronBufferGeometry attach=\"geometry\" args={[1,30]} />\r\n            <shaderMaterial args={[Shader]}/>\r\n        </mesh>\r\n        <group >\r\n            <Text \r\n                position={[-2.0,0.0,0.0]}\r\n                color={'#000000'}\r\n                fontSize={0.8}\r\n                >\r\n                {'optimizn.'}\r\n            </Text>\r\n            <Text\r\n                position={[-1.5, -1.0, 0.0]}\r\n                color={'#000000'}\r\n                fontSize={0.4}\r\n                >\r\n                {'innovative and\\ncreative development'}\r\n            </Text>\r\n        </group>\r\n        </>\r\n    )\r\n}","import './App.css';\nimport { Canvas } from '@react-three/fiber';\nimport Animation from './components/Animation';\n\nfunction App() {\n  \n  return (\n    <div  style={{ width: \"100vw\", height: \"100vh\" }}>\n\n      <Canvas>\n        <Animation />\n        \n      </Canvas>\n      </div>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}